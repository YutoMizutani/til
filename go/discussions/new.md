## New

[#メソッドとゼロ値 - GoでNewなんとかのような関数を不必要に提供しないほうが良い理由 | Qiita](https://qiita.com/ruiu/items/54aa82b0088686b95724#メソッドとゼロ値)
> Goでは新しい値は「ゼロ値」で自動的に初期化される。ゼロ値は型ごとに違うが、数値なら0、文字列なら空文字列、ポインタやインターフェイスならnil、といった具合の値だ。構造体ならそれぞれのフィールドがゼロ値で初期化される。
メソッドはそのレシーバーの値のゼロ値に対して問題なく動くように書くほうがよい。構造体Tを割り当てて初期化する関数としてNewTみたいな関数を用意するのは、本当に初期化が必要なとき以外はやらないほうがよい。
なぜか、というといくつか理由がある。
NewTの代わりにnew(T)を使うようにすると、エクスポートされる関数が一つ減る。APIがそのぶん多少簡単になる。
var x Tや&T{}のような書き方でも値を割り当てられるようになる。
Tを別の構造体Uのフィールドとして使った時に、Tがゼロ値で動くなら、Uも単純にnew(U)などで割り当てられるようになる。NewTが必須だとしたら、Tではなく*Tをフィールドとして使わないといけなくなるし、NewTを内部で呼ぶNewUも用意しないといけなくなる。アロケーションが2回になってしまう。
Newを必要としない型の好例の一つはsync.Mutexで、そのゼロ値はロックされていないミューテックスとして正当な値ということになっているので、他の構造体のフィールドにするのが簡単になっている。
bytes.Bufferも初期化を必要としない。bytes.NewBufferという関数も用意されているけど、これはバッファの長さの初期値を与えたうえで初期化するというオプショナルな機能で、使うのは必須ではない。

> たしかにそういう場面はあると思うのですけど、手元にすべてコードがあるなら、その構造体を割り当てている箇所というのは簡単にわかるので全部直せませんか？ そうでないのなら他の人も使っているpublic APIをコンパイルできないように変えるのはちょっと大胆かなぁという気も。むろんそういうケースがないといっているわけではなくて、あるとも思うので、「なるべく」という表現にとどめたということで。

[GoでNewなんとかのような関数を不必要に提供しないほうが良い理由](https://qiita.com/ruiu/items/54aa82b0088686b95724)
